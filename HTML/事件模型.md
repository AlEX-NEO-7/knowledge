# DOM事件流
事件流描述的是从页面中接收事件的顺序。

事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。

包括三个阶段：

1. 事件捕获阶段：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)
2. 处于目标阶段：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。
3. 事件冒泡阶段：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发，当一个元素接收到事件的时候会把他接收到的事件传给自己的父级，一直到window 。

## 概述
在dom模型中，html是多层次的，当一个html元素上产生事件时，该事件会在dom树元素节点之间按照特定的顺序去传播。传播路径的每一个节点，都会收到这个事件，这就是dom事件流。

- JS代码只能执行捕获或者冒泡其中的一个阶段
- onclick 和 attachEvent 只能得到冒泡阶段
- addEventListener (type, listener[, useCapture]) 第三个参数如果是true，表示在事件捕获阶段调用事件处理函数；如果是false（不写默认就是false），表示在事件冒泡阶段调用事件处理函数。
- 在实际开发中，我们很少使用事件捕获(低版本ie不兼容)，我们更关注事件冒泡
- 有些事件是没有冒泡的，比如onblur、onfocus、onmouseover、onmouseleave

## 事件对象
- event 就是一个事件对象，写在我们的监听函数的小括号里面，当做形参
- 事件对象只有有了事件才会存在，他是系统给我们自动创建的，不需要我们传递参数

### 常见属性和方法
```e.target```: 返回触发事件的对象标准
```e.preventDefault()```: 阻止默认事件
```e.stopPropagation()```: 阻止冒泡

### e.target和this的区别
- this返回的是绑定事件的对象（元素）。
- e.target返回的是点击的那个对象，即触发该事件的对象。
```
let ul = document.querySelector('ul');
ul.addEventListener('click', function(e){
   console.log(this); // <ul>...</ul>
   console.log(e.target); // <li>123</li>
})
```

## 事件代理
事件委托的原理：不给每个子节点单独设置事件监听器，而是设置在其父节点上，然后利用冒泡原理设置每个子节点。

> 只操作了一次 DOM ，提高了程序的性能。

### 为什么要事件委托
在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的操作dom,那么引起浏览器重绘和回流的可能也就越多，页面交互的事件也就变的越长，这也就是为什么要减少dom操作的原因。每一个事件处理函数，都是一个对象，那么多一个事件处理函数，内存中就会被多占用一部分空间。如果要用事件委托，就会将所有的操作放到js程序里面，只对它的父级(如果只有一个父级)这一个对象进行操作，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；
