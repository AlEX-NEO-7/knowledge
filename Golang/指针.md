# 指针
一般变量传递会有两种：
- 值拷贝(值类型)
> 开辟一块新的内存空间，存放原值的副本，副本与原值互相不干扰
- 值传递(引用类型)
> 开辟一块新的内存空间，存放原值的内存地址，可通过原值的内存地址访问到原值

## GO中的指针
- 取地址符: &
- 取值符: *
- 数据类型: *指向的类型(*int...)

引用已有的变量可通过内建函数```new()```来分配内存
```
var aNewPot *int
aNewPot = new(int)
*aNewPot = 666
fmt.Printf("aNewPot: %p %#v %#v \n", &aNewPot, aNewPot, *aNewPot)
```
### new和make的区别
- new和make都在堆上分配内存，但是它们的行为不同，适用于不同的类型。

- new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &T{}。

- make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：slice、map 和 channel。

- 换言之，new 函数分配内存，make 函数初始化.

> 引用类型的默认值为nil，需要分配内存空间（引用已有值类型，或通过内建函数new()/make()来分配）
